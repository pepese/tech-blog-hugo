---
title: RDB設計
tags:
- RDB
id: rdb-basict
draft: true
---

# 3 層スキーマ

- 外部スキーマ
    - テーブルやビュー
    - ユーザから見たデータベース
- 概念スキーマ
    - テーブル定義（データの要素やデータ同士の関係）
    - 開発者から見たデータベース
    - 論理設計
- 内部スキーマ
    - テーブルやインデックスの物理定義（データファイルの物理的配置）
    - RDBMS から見たデータベース
    - 物理設計

# 内部設計

1. エンティティの抽出
2. エンティティの定義
    - データの属性、キーを定義
3. 正規化
4. ER 図の作成

# 物理設計

1. テーブル定義
2. インデックス定義
3. ハードウェアサイジング
4. ストレージの冗長性構成決定
5. ファイルの物理配置決定
    - データファイル
    - インデックスファイル
    - システムファイル
    - 一時ファイル：サブクエリの展開やソートデータ
    - ログファイル

||用途|ユーザアクセス|データ量増加|性能考慮|
|:---|:---|:---|:---|:---|
|データファイル|テーブルデータの格納|有|有|高|
|インデックスファイル|インデックスの格納|有|有|高|
|システムファイル|管理用データの格納|無|有|低|
|一時ファイル|一時データの格納|無|無|高|
|ログファイル|更新ログの格納|無|無|中|

# バックアップ設計

|項目|フルバックアップ|差分バックアップ|増分バックアップ|
|:---|:---|:---|:---|
|バックアップ対象データ|すべて|前回フルバックアップからの差分|前回任意のバックアップからの差分|
|バックアップ処理時間|大|中|小|
|リカバリ処理時間|小|中|大|

# 論理設計と正規化

## 制約

- NOT NULL 制約
- 一意制約
- CHECK 制約

## 正規化

冗長性と非一貫性を排除する。  
レベル 5 まであるが、 3 までで十分。

- 第 1 正規形
    - 1 つのセルには 1 つの値しかない
- 第 2 正規形
    - 部分関数従属を解消し、完全関数従属になった形
- 第 3 正規形
    - 推移的関数従属を解消した形
- ボイスコット正規形
- 第 4 正規形
- 第 5 正規形

# パフォーマンス

RDB のパフォーマンスを決める要因は主に以下の 2 つ。

- インデックス
- 統計情報

## インデックス

インデックスは主に B+Tree で構成される。  
インデックスは以下の列に作成する。

- 大規模なテーブルの列
- カーディナリティの高い列
    - カーディナリティ：取りうる値のバリエーション数
- where 句の選択条件、結合条件

以下の場合、インデックスが使用されないので注意が必要。

- インデックス列に演算を行なっている
- インデックス列に対して SQL の関数を適用している
- インデックス列に対して IS NULL 述語を使用している
- インデックス列に対して 否定形 を使用している
- インデックス列に対して OR を使用している
- インデッックス列に対して、後方一致、中間一致の LIKE を使用している
    - 前方一致は大丈夫
- インデックス列に対して 暗黙の型変換を行なっている

その他の注意点には以下がある。

- 主キー、一意制約列にはインデックス作成不要
- インデッックスは数値型、文字列型に適用し、一定桁数であることが望ましい
- 更新されるカラムには適用しない
- インデックスは検索性能は上がるが、更新性能は下がる
    - 頻繁に更新されるテーブルには不向き
- 定期的なメンテナンスを行うことが望ましい

B+Tree 以外のインデックスには以下がある。

- ハッシュインデックス
    - 範囲検索（100〜200までの値を検索したい等）は出来ないが等価比較（123という値を検索したい等）による検索は非常に早い
- 全文検索インデックス
    - 行に含まれる単語や文字列で構成されたインデックス、英字には強いが日本語に弱い
- Rツリーインデックス
    - 最小外接矩形という図形を用いた概念で構成される
- 関数インデックス
    - 関数を適用したクエリでインデックスを使いたい場合に有効
- ビットマップインデックス
    - カラムをビットで判定していてインデックスのスキャンは高速になるが、更新処理だと時間がかかる

## 統計情報

いわゆる **オプティマイザ** と **実行計画** 。  
以下のように処理される。

1. パーサ
    - SQL を受け取り、構文チェックする
2. オプティマイザ
    - カタログマネージャにアクセスする
3. カタログマネージャ
    - 統計情報を管理し、オプティマイザに渡す
4. オプティマイザ
    - カタログマネージャから得た統計情報から最短経路を選択する（実行計画、実行プラン、アクセスプラン）

統計情報は RDBMS により自動で更新されるため、データが大きく更新された後なるべる早く確認する必要がある。  
統計情報をある時点で凍結・固定する、という戦略もある。

## パフォーマンスのその他の話題

- 正規化のトレードオフ
    - 正規化すると更新性能はあがるが、 **テーブル結合** を伴う参照性能は低下する
- テーブル分割
    - 水平分割
        - レコードの分割、いわゆるシャーディング
        - I/O ネック解消のために実施される
        - RAID や RDBMS の機能である **パーティショニング** を使用する方がいい
    - 垂直分割
        - 列の分割
        - 集約（合計、平均など）のデータが欲しい場合に実施される
        - ある目的のために垂直分割されたテーブルを **データマート** （単に **マート** ）とよぶ
            - データの同期がネックになる
        - 集約結果のテーブル（ **サマリテーブル** ）を作成するのも手

# SQL

**SQLは集合で考える** 。

## case 式

```
case when sex = '1' then '男'
     when sex = '2' then '女'
else 'その他' end
```

注意点は以下。

1. 分岐が返却するデータ型を統一する
2. `end` 、 `else` を忘れない

集計関数内や `check` 句、条件別の `update` などにも利用できて便利。

## 自己結合

```
select p1.name as name_1, p2.name as name_2
  from Products p1, Products p2
 where p1.name <> p2.name;
# where p1.name > p2.name;
# where p1.name < p2.name;
```

## having 句

`group by` 句によりグループ化された情報に対して条件を設定する場合は、 `having` 句を用いる。

### 際頻値

```
select namek count(*) as cnt
  from Products
 group by name
having count(*) >= all ( select count(*)
                           from products
                          group by name);
```

- `all`
    - どの値よりも大きい
- `any`
    - 少なくともどれか 1 つの値よりも大きい

## SQL パフォーマンス

- `in` より `exists` を使う
    - `exists` は要素を発見した時点で検索を終了する
- ソートを回避する
    - `group by` 、 `order by` 、 集合関数 、 `distinct` 、 `集合演算子 、 OLAP 関数
    - `all` オプションをうまく使う
    - `distinct` を `exists` で代用する
- インデックスを使う
- 中間テーブルを使う