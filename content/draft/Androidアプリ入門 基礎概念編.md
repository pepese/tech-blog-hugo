---
title: "Androidアプリ入門 基礎概念編"
date: 2020-02-21T13:44:17+09:00
slug: ""
tags:
- tag_name
draft: true
archives:
- 2019/06
---

今更だが、Android開発についてまとめる。

- アプリの基礎
- アプリのコンポーネント
- マニフェストファイル

[Developers Guide](https://developer.android.com/guide?hl=ja)

<!--more-->

# アプリの基礎

- Android アプリ開発は Kotlin や Java、C++ 言語を使用
- Android SDK ツールは、コードをデータやリソース ファイルと一緒に APK（Android パッケージ `.apk` ）にコンパイル
- 各 Android アプリはそれぞれのセキュリティ サンドボックス内で動作し、以下の Android のセキュリティ機能により保護
  - Android オペレーティング システムはマルチユーザの Linux システムであり、各アプリがそれぞれ異なるユーザになる
  - 各アプリに一意の Linux ユーザ ID が割り当てられ（ID はシステムのみで使用され、アプリは ID を関知しない）、このユーザ ID のみがアプリ内のすべてのファイルにアクセスできるよう、パーミッションが設定される
  - 各プロセスにはそれぞれ独自の仮想マシンがあるため、アプリのコードは他のアプリとは分離して実行される
  - すべてのアプリは独自の Linux プロセスで実行され、Android システムはアプリのコンポーネントのいずれかを実行する必要があるときにプロセスを開始し、それが必要なくなったときや、システムが他のアプリ用にメモリを回復させる必要があるときにプロセスをシャットダウンする
  - Android システムには「最小権限の原則」が適用される

# アプリのコンポーネント

- アクティビティ
- サービス
- ブロードキャストレシーバ
- コンテンツプロバイダ

## アクティビティ

**アクティビティ** は、ユーザとやり取りするためのエントリポイント。  
これは、1 つのユーザ インターフェースを持つ 1 つの画面。  
例えば、メールアプリには、新着メールの一覧を表示するアクティビティ、メールを作成するアクティビティ、そしてメールを閲覧するアクティビティがある。  
アクティビティは Activity クラスのサブクラスとして実装する。（ [詳細](https://developer.android.com/guide/components/activities?hl=ja) ）  
ユーザインタフェースの挙動や部品については [**フラグメント**](https://developer.android.com/guide/components/fragments?hl=ja) を参照。

## サービス

**サービス** は、アプリをバックグラウンドで実行し続けるための汎用エントリポイントでユーザインターフェースが無い。  
例えば、サービスはユーザが別のアプリを使用している間にバックグラウンドで音楽を再生したり、ユーザが別のアクティビティを操作している間にそれを妨げることなくネットワークからデータを取得したりする。  
アクティビティなどの他のコンポーネントが、サービスを開始して実行したり、サービスとやり取りするためにサービスにバインドしたりすることができる。  
アプリの管理方法についてサービスがシステムに通知するセマンティクスは 2 つあり、それぞれ異なる意味つ。

- 音楽の再生はユーザが直接意識しているものなので、アプリはフォアグラウンドになりたいことをユーザに通知で知らせることで、システムにそれを指示する。この場合、システムはそのサービス プロセスの実行を維持するよう最善を尽くす。このプロセスが終了するとユーザが不満を覚えるから。
- 通常のバックグラウンド サービスは、その実行をユーザが直接意識していない。したがって、システムはより柔軟にそのプロセスを管理でる。ユーザにとってより緊急な課題を処理するために RAM が必要となった場合には、プロセスを強制終了し、後から再開できる。

サービスは Service のサブクラスとして実装する。（ [詳細](https://developer.android.com/guide/components/services?hl=ja) ）

## ブロードキャストレシーバ

**ブロードキャストレシーバ** は、通常のユーザフローを外れて、システムがアプリにイベントを配信できるようにするコンポーネント。  
これにより、アプリはシステム全体のブロードキャスト アナウンスに応答できる。  
ブロードキャストレシーバは明確に定義されたアプリへのエントリであるため、システムは実行中でないアプリに対してもブロードキャストを配信できる。  
したがってアプリが、例えば、近づいているイベントについてユーザに知らせる通知を投稿するためのアラームをスケジューリングすることができる。  
アプリの BroadcastReceiver にアラームを配信することにより、そのアラームが作動するまでアプリの実行を維持する必要がなくなる。  

- 多くのブロードキャストの発信源はシステム — 例えば、画面がオフになったことを通知するブロードキャスト、電池が残り少ないことを通知するブロードキャスト、画像がキャプチャされたことを通知するブロードキャストなど。
- アプリから発信されるブロードキャストもある — 例えば、端末にデータがダウンロードされ使用できることを他のアプリに知らせる場合など。

ブロードキャストレシーバがユーザ インターフェースを表示することはないが、ステータスバー通知を作成して、ブロードキャスト イベントの発生時にユーザにアラートできる。  
一般的には、ブロードキャストレシーバは他のコンポーネントへの単なるゲートウェイであり、最小限の作業を行うことが前提となっている。  
例えば、JobScheduler を使用してイベントに基づいた何らかの作業を実行する JobService をスケジュール設定する場合など。  
ブロードキャストレシーバは BroadcastReceiver のサブクラスとして実装され、各ブロードキャストは Intent オブジェクトとして配信される。（ [詳細](https://developer.android.com/reference/android/content/BroadcastReceiver?hl=ja) ）

## コンテンツプロバイダ

**コンテンツプロバイダ** は、ファイル システム、SQLite データベース、ウェブ、またはアプリからアクセス可能な他の永続的なストレージの場所に保存できるアプリデータの共有されている部分を管理する。  
コンテンツプロバイダを介して、他のアプリがデータをクエリしたり、修正したりできる（コンテンツプロバイダが許可している場合）。  
例えば、Android システムはユーザの連絡先情報を管理するコンテンツプロバイダを提供している。したがって、適切なパーミッションさえあれば、アプリからコンテンツプロバイダに ContactsContract.Data などをクエリして、特定の人物に関する情報を読み取ったり書き込んだりでる。  
このような一般的なケースのために多くの API やサポートが組み込まれているため、コンテンツプロバイダをデータベースの抽象化として考えたくなるかもしれないが、システム設計の観点では、コンテンツプロバイダには別の目的がある。  
システムから見て、コンテンツプロバイダは、URI スキームにより識別される名前付きデータ項目を公開するための、アプリへのエントリ ポイントとなる。したがって、アプリは自身が保有するデータを URI 名前空間にどのようにマッピングし、その URI を他のエンティティに渡してデータにアクセスできるようにするかを決めることができる。  
アプリの管理に関して、システムでは以下が実行できる。

- URI の割り当てはアプリが実行中であるかどうかには影響されないため、その URI を所有しているアプリが終了していても URI は維持される。システムが確認する必要があるのは、該当 URI からアプリのデータを取得する必要があるときに、所有しているアプリが実行中であることだけ。
- URI は重要で詳細なセキュリティ モデルも提供する。例えば、アプリは画像の URI をクリップボードに配置することができますが、他のアプリが自由にアクセスできないようにコンテンツプロバイダをロックしたままにできる。別のアプリがクリップボードのその URI にアクセスしようとした場合には、システムが一時的な URI パーミッションを付与して、その URI にあるデータのみにアクセスすることを許可する。その他のデータにはアクセスできない。

システムがコンポーネントを開始すると、そのアプリのプロセスがまだ実行されていない場合にはプロセスを開始し、コンポーネントに必要なクラスをインスタンス化する。  
例えば、写真を撮影するカメラアプリのアクティビティをアプリで開始すると、そのアクティビティはアプリのプロセスではなく、カメラアプリのプロセスで実行する。  
そのため、他の多くのシステムのアプリとは異なり、Android アプリのエントリ ポイントは 1 つではない（ `main()` 関数はない）。  

他のシステムでは各アプリを別々のプロセスで実行しており、かつ他のアプリへのアクセスを制限するファイル許可があるので、別のアプリのコンポーネントを直接アクティベートすることはできない。  
しかし、Android システムならそれができる。  
別のアプリのコンポーネントをアクティベートするには、特定のコンポーネントを開始するインテントを指定するメッセージをシステムに配信する。  
その後、システムが代わりにコンポーネントをアクティベートする。

## コンポーネントをアクティベートする

4 タイプあるコンポーネントのうちの 3 タイプ（アクティビティ、サービス、ブロードキャストレシーバ ）は、 **インテント** と呼ばれる非同期メッセージによりアクティベートされる。  
インテントは個々のコンポーネントをランタイム時に互いにバインドする。  
コンポーネントが属しているアプリが何であるかにかかわらず、他のコンポーネントからのアクションをリクエストするメッセンジャーとみなすことができる。  

インテントは Intent オブジェクトを使用して作成され、特定のコンポーネント（明示的インテント）、もしくは特定のタイプのコンポーネント（暗黙的インテント）をアクティベートするメッセージを定義する。  

アクティビティとサービスの場合、実行するアクション（表示や送信など）をインテントが定義し、操作のベースとなるデータ（特に、開始されるコンポーネントが知っておく必要があるデータ）の URI を指定することもできる。  
例えばインテントは、画像を表示したり、ウェブページを開いたりするアクティビティを求めるリクエストを伝達できる。  
結果を受け取るようなアクティビティを開始することもできる。  
このようなケースでは、アクティビティは Intent で結果を返すこともできる。  
例えば、ユーザが個人の連絡先を選んで、あなたに返すことができるようなインテントを発行できる。この場合の返信インテントには、選択された連絡先をポイントする URI が含まれる。

ブロードキャスト レシーバの場合、インテントは単純にブロードキャストされるアナウンスを定義する。  
例えば、端末の電池の残量が少ないことを示すブロードキャストには、電池が少ないことを示す既知のアクション文字列のみが含まれる。  

アクティビティ、サービス、ブロードキャスト レシーバとは異なり、コンテンツプロバイダはインテントではアクティベートされない。
ContentResolver からのリクエストにより指定された場合にアクティベートされる。  
コンテンツ リゾルバが、コンテンツプロバイダを使ってすべてのトランザクションを直接処理することで、プロバイダを使ってトランザクションを実行しているコンポーネントによる処理が不要になり、代わりに ContentResolver オブジェクトのメソッドを呼び出す。  
これによりコンテンツプロバイダと情報をリクエストしているコンポーネントとの間に（セキュリティ目的で）抽象的な層ができる。  

それぞれのタイプのコンポーネントをアクティベートする個別のメソッドがある。

- アクティビティを開始する、または新しい作業を与える場合は、Intent を startActivity() または startActivityForResult()に渡す。
- Android 5.0（API レベル 21）以降では、JobScheduler クラスを使用してアクションをスケジュール設定できる。それより前のバージョンの Android の場合、サービスを開始する（または続行中のサービスに新しい指示を与える）には、Intent を startService() に渡す。サービスにバインドするには、Intent を bindService() に渡す。
- ブロードキャストを開始するには、Intent を、sendBroadcast()、sendOrderedBroadcast()、sendStickyBroadcast() などのメソッドに渡す。
- コンテンツプロバイダにクエリを実行するには、ContentResolver の query() を呼び出す。

[詳細](https://developer.android.com/guide/components/intents-filters?hl=ja)

# マニフェストファイル

Android システムがコンポーネントを開始できるようになるには、アプリの **マニフェストファイル**（ `AndroidManifest.xml` ）を読み取ることで、当該コンポーネントがあることを認識しなければならない。  
アプリはすべてのコンポーネントをこのファイルで宣言し、アプリ プロジェクト ディレクトリのルートにこのファイルを置く必要がある。  
マニフェストはアプリのコンポーネントを宣言する以外に、次のようにさまざまなことを行う。

- インターネット アクセスや、ユーザの連絡先への読み取りアクセスなど、アプリに必要なユーザ パーミッションを識別する。
- アプリが使用する API に基づいて、アプリが必要とする最小 API レベルを宣言する。
- カメラ、Bluetooth サービス、マルチタッチ スクリーンなど、アプリで使用されるか必要とされるハードウェア機能やソフトウェア機能を宣言する。
- Google マップ ライブラリなど、アプリにリンクする必要のある API ライブラリ（Android フレームワーク API は除く）を宣言する。

## コンポーネントを宣言する

マニフェストファイルでアクティビティの宣言はを次のようになる。

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>
```

- `<application>` 要素の android:icon 属性でアプリを特定するアイコンのリソースを指定
- `<activity>` 要素の android:name 属性で Activity サブクラスの完全修飾クラス名を指定し、android:label 属性でアクティビティのユーザに表示するラベルとして使用する文字列を指定

以下の要素を使用して、アプリのすべてのコンポーネントを宣言する。

- アクティビティ： `<activity>` 要素
- サービス： `<service>` 要素
- ブロードキャストレシーバ： `<receiver>` 要素
- コンテンツプロバイダ： `<provider>` 要素

ソースに含まれていても、マニフェストで定義されていないアクティビティ、サービス、コンテンツプロバイダは、システムからは見えないため、実行されることはない。  
ただし、ブロードキャスト レシーバはマニフェストで宣言することもでき、BroadcastReceiver オブジェクトとしてコードで動的に作成し、registerReceiver() を呼び出すことでシステムに登録することもできる。  
[マニフェストファイルの詳細](https://developer.android.com/guide/topics/manifest/manifest-intro?hl=ja)

## コンポーネントの機能を宣言する

コンポーネントをアクティベートするで上述したように、Intent を使用してアクティビティ、サービス、ブロードキャスト レシーバを開始できる。  
Intent を使用するには、インテントでターゲットのコンポーネントのクラス名前を明示的に指定する必要がある。  
暗黙的インテントを使用して、実行するアクションのタイプを指定することもできる。  
任意で、実行するアクションの基となるデータも指定できる。  
暗黙的インテントにより、システムはアクションを実行できる端末上のコンポーネントを見つけ、開始することができる。  
インテントで記述されたアクションを実行できるコンポーネントが複数ある場合は、ユーザが使用するコンポーネントを 1 つ選択できる。

アプリのマニフェストでアクティビティを宣言するときに、任意でアクティビティの機能を宣言するインテント フィルタを含めて、他のアプリからのインテントに応答できるようにできる。  
`<intent-filter>` 要素を、コンポーネントを宣言している要素の子として追加することで、コンポーネントのインテント フィルタを宣言できる。  
例えば、新規メールを作成するアクティビティを持つメールアプリをビルドした場合、次の例のように、（新規メールを送信するための）「送信」インテントに応答するインテント フィルタを宣言できる。

```xml
<manifest ... >
    ...
    <application ... >
        <activity android:name="com.example.project.ComposeEmailActivity">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <data android:type="*/*" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

別のアプリが `ACTION_SEND` アクションを含むインテントを作成し、`startActivity()` に渡した場合、ユーザがメールを下書きして送信できるよう、システムがアクティビティを開始する。  
[インテントフィルタの詳細](https://developer.android.com/guide/components/intents-filters?hl=ja)

## アプリの要件を宣言する

アプリに必要な機能を搭載していない端末にアプリをインストールしてしまわないよう、アプリがサポートする端末のタイプについてプロファイルで明確に定義し、マニフェスト ファイルで端末の要件やソフトウェア要件を宣言しておく必要がある。  
これらの宣言のほとんどはただの情報で、システムがそれを読み取ることはないが、Google Play などの外部サービスはそれを読み取って、ユーザが端末からアプリを検索したときにフィルタリングする。  
例えば、あなたのアプリがカメラを必要とし、Android 2.1 で導入された API（API レベル 7）を使用している場合、次のようなマニフェストファイルになる。

```xml
<manifest ... >
    <uses-feature android:name="android.hardware.camera.any"
                  android:required="true" />
    <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="19" />
    ...
</manifest>
```

[端末の互換性](https://developer.android.com/guide/practices/compatibility?hl=ja)

# アプリのリソース

Android アプリは、コードだけでなく、画像、オーディオ ファイル、アプリの外観に関連するものなど、リソースが必要。  
例えば、アクティビティのユーザインターフェースのアニメーション、メニュー、スタイル、色、レイアウトなどを XML ファイルで定義できる。  

Android プロジェクトに含めるすべてのリソースに対し、SDK ビルドツールが一意の整数 ID を定義する。  
これを使用して、アプリコードや XML で定義された他のリソースからリソースを参照できる。  
例えば、アプリに `logo.png` という名前の画像ファイルがある場合（ `res/drawable/` ディレクトリに保存）、SDK ツールが `R.drawable.logo` という名前のリソース ID を生成する。  
この ID はアプリに固有の整数にマップされ、これを使用して画像を参照したり、ユーザインターフェースに挿入したりできる。  

リソースとソースコードを分離して提供することの最も重要な側面は、さまざまな端末構成に合わせて代替リソースを提供できるという点。  
例えば、XML で UI 文字列を定義することで、その文字列を他の言語に翻訳して別のファイルに保存しておくことができる。  
その後、リソースのディレクトリ名に付けた言語の修飾子（例え亜h馬フランス語の文字列値なら `res/values-fr/` ）とユーザの言語設定に基づいて、Android は UI に適切な言語の文字列を適用する。  

Android では代替リソースのためにさまざまな **修飾子** を多数サポートしている。  
修飾子は、リソースのディレクトリ名に含める短い文字列で、そのリソースを使用する端末構成を定義するもの。  
例えば、端末の画面の向きやサイズに応じて、アクティビティのレイアウトを複数作成することがある。端末の画面が縦向き（縦長）の場合にはボタンのレイアウトを縦に並べ、端末が横向き（横長）の場合はボタンを横並びにする、といった具合。
画面の向きによってレイアウトを変更するには、2 つの異なるレイアウトを定義して、それぞれのレイアウトのディレクトリ名に適切な修飾子を適用する。  
そうすることで、現在の端末の向きに合わせて、システムが適切なレイアウトを自動的に適用する。  
[リソースの詳細](https://developer.android.com/guide/topics/resources/providing-resources?hl=ja)  

# [アプリのアーキテクチャ](https://developer.android.com/jetpack/docs/guide?hl=ja)
